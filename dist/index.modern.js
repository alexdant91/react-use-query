import{createContext as e,useState as t,useContext as o,useRef as r,useEffect as a}from"react";function n(){return n=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var o=arguments[t];for(var r in o)Object.prototype.hasOwnProperty.call(o,r)&&(e[r]=o[r])}return e},n.apply(this,arguments)}const i={selector:void 0,manipulate:void 0,method:"GET",headers:void 0,body:void 0,isDebuggerActivated:!1,cacheTimeout:0};let c=null;const s=(e="",t=!1,o=!1,r=null)=>{o?t&&console.error(`[USE_QUERY]: ${e} - ${(new Date).toLocaleTimeString()}`,r):t&&console.log(`[USE_QUERY]: ${e} - ${(new Date).toLocaleTimeString()}`)},d=e=>{const t=Object.keys(i),o=Object.keys(e).filter(e=>!t.includes(e));return void 0!==e.selector&&"string"!=typeof e.selector?(s("Validation error for `options.selector`",isDebuggerActivated,!0,new Error("Selector must be a string. It should contains key value to select from result object.")),!1):void 0===e.method||"string"==typeof e.method&&-1!==["GET","POST","PUT","PATCH","DELETE"].indexOf(e.method.toUpperCase())?void 0!==e.headers&&"object"!=typeof e.headers&&Array.isArray(e.headers)?(s("Validation error for `options.headers`",isDebuggerActivated,!0,new Error("Headers must be an object. It should contains request headers key value.")),!1):void 0!==e.isDebuggerActivated&&"boolean"!=typeof e.isDebuggerActivated&&Array.isArray(e.headers)?(s("Validation error for `options.isDebuggerActivated`",!0,!0,new Error("isDebuggerActivated must be a boolean. It should be activated if you need to debug all process.")),!1):void 0!==e.manipulate&&"function"!=typeof e.manipulate?(s("Validation error for `options.manipulate`",!0,!0,new Error("manipulate must be a function. It rappresent the funcion to manipulate data before saving on state.")),!1):void 0!==e.cacheTimeout&&"number"!=typeof e.cacheTimeout?(s("Validation error for `options.cacheTimeout`",!0,!0,new Error("cacheTimeout must be a number. It rappresent the timeout to remove cached data from memory in milliseconds.")),!1):!(o.length>0&&(s("Validation error",!0,!0,new Error(`Found not valid option${o.length>1?"s":""}: "${o.join('", "')}".`)),1)):(s("Validation error for `options.method`",isDebuggerActivated,!0,new Error('Method must be a string. It should be one of "GET", "POST", "PUT", "PATCH", "DELETE".')),!1)},u=(e,t)=>{e.cacheTimeout&&e.cacheTimeout>0&&(s(`Cache clear timeout start: ${e.cacheTimeout/1e3} seconds.`,e.isDebuggerActivated),clearTimeout(c),c=setTimeout(()=>{t.current={},s("Cache cleared",e.isDebuggerActivated)},e.cacheTimeout))},l=e(null),m=({children:e})=>{const[o,r]=t(null);return h(l.Provider,{value:[o,r]},e)},f=()=>o(l),p=(e,o=n({},i))=>{const{selector:c,manipulate:l,method:h,headers:m,body:p,isDebuggerActivated:g}=n({},i,o);d(n({},i,o));const b=r({}),[v,y]=f(),[T,E]=t(null),[A,D]=t(!1),w=async()=>{if(s("Fetching data...",g),T&&E(null),A||D(!0),b.current[e])return s("Get data from cache, no need a new request",g),"function"==typeof l&&s("Manipulate data before saving",g),y(b.current[e]),u(o,b),void D(!1);try{s("No data found in cache, proceed to do a new request...",g);const t=await fetch(e,{method:h,headers:m,data:p}),r=await t.json();if(t.ok){const t=c?r[c]:r;"function"==typeof l&&s("Manipulate data before saving",g),y("function"==typeof l?l(t):t),s("Request done",g),b.current[e]="function"==typeof l?l(t):t,u(o,b),s(`New data saved on cache for: "${e}"`,g)}else E(r),s("An error occurred",g,!0,r)}catch(e){E(e),s("An error occurred",g,!0,e)}finally{D(!1),s("Data seatled, process done",g)}};return a(()=>{w()},[e]),{data:v,error:T,loading:A,updateData:y,refresh:w,cache:{get:e=>e?b.current[e]:b.current,has:e=>b.current[e],clear:()=>{b.current={},s("Cache cleared",g)}}}};export{m as QueryProvider,p as useQuery,f as useQueryContext};
//# sourceMappingURL=index.modern.js.map
